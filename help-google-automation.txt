Print LSB (Linux Standard Base) and Distribution information.

lsb_release -a


python --version
python -V
python2 --version
python3 --version


shebang line examples
#!/usr/bin/env python3
#!/usr/bin/python


Ubuntu:
ls /usr/lib/python3.8/dist-packages
Manjaro:
ls /usr/lib/python3.8


__init__.py







Misc
----
split()
strip()
word.lower()
word.isalpha()

punctuations = '''!()-[]{};:'"\,<>./?@#$%^&*_~'''
new_file_contents = ''.join(char for char in file_contents if char not in punctuations)


department_list.count("IT")



read /write files
-----------------
file = open('test.txt')
file.close()

with open('test.txt') as file:
    for line in file:
        print(line.strip())

line = file.readline()
next_line = file.readline()
rest_of_file = file.read()

lines = file.readlines()


modes:
'r'	open for reading (default)
'w'	open for writing, truncating the file first !!!
'x'	open for exclusive creation, failing if the file already exists
'a'	open for writing, appending to the end of the file if it exists
'b'	binary mode
't'	text mode (default)
'+'	open for updating (reading and writing)


os
--
https://docs.python.org/3/library/os.html
https://docs.python.org/3/library/os.path.html

os.getcwd()
os.mkdir('temp_dir')
os.chdir('temp_dir')
os.rmdir('temp_dir')
os.listdir('/')
os.listdir(path='.')

os.scandir(path='.')
	Returns an iterator

	Using scandir() instead of listdir() can significantly increase the performance of code that also needs file type or file attribute information


	with os.scandir(path) as it:
	    for entry in it:
	        if not entry.name.startswith('.') and entry.is_file():
	            print(entry.name)


os.remove('my.txt')
os.rename('draft.txt', 'final.txt')
os.path.exists('draft.txt')

os.path.abspath('test_math.py')
os.path.isfile(file)
os.path.isdir(file)
os.path.join(dir, name)
os.path.dirname(path)

os.stat('somefile.txt')


# File size in bytes
os.path.getsize('draft.txt')

# Last modified time (unix time)
os.path.getmtime('draft.txt')

# Return the time of last access of path
os.path.getatime(path)



os.environ
os.environ['HOME']
os.environ['PATH']

os.getenv('HOME')
os.getenv('PATH')
os.putenv(key, value)


os.getpid()
os.getppid()
os.uname()

os.sep
os.linesep


csv
---
https://docs.python.org/3/library/csv.html
https://realpython.com/python-csv/

Note: Files below should be opened with newline=''
		with open('person.csv', newline='') as csvfile:


with open('person.csv', 'r') as f:
    csv_file = csv.reader(f)
    for row in csv_file:
        name, gender, age = row

persons = [['Jan', 'Man', 32], ['Piet', 'Man' ,45], ['Joke' ,'Vrouw', 34]]
with open('my_persons.csv', 'w') as f:
    csv_file = csv.writer(f)
    csv_file.writerows(persons)


with open('personHeader.csv', 'r') as f:
    csv_file = csv.DictReader(f)
    for row in csv_file:
        print(row['Name'], row['Age'])


persons = [{'Name': 'Jan', 'Gender': 'Man', 'Age': 27},
           {'Name': 'Piet', 'Gender': 'Man' ,'Age': 45},
           {'Name': 'Joke' ,'Gender': 'Vrouw', 'Age':34}]
with open('my_persons_header.csv', 'w') as f:
    keys = ['Name', 'Gender', 'Age']
    csv_file = csv.DictWriter(f, fieldnames=keys)
    csv_file.writeheader()
    csv_file.writerows(persons)


csv.register_dialect('myDialect', skipinitialspace=True, strict=True)
csv.DictReader(f, dialect = 'myDialect')



math
----
math.pi


datetime
--------
unixtime = os.path.getmtime('test_math.py')
datetime.datetime.fromtimestamp(unixtime)
#datetime.datetime(2020, 10, 9, 17, 30, 52, 145723)


shutil
------
du = shutil.disk_usage("/")
du.free / du.total
du.used / du.total


psutil
------
psutil.cpu_percent(0.1)


requests
--------
# sudo apt install python3-requests
request = requests.get("http://www.google.com")
request.status_code == 200


socket
------
localhost = socket.gethostbyname('localhost') # Returns '127.0.0.1'


re
--
https://www.regex101.com
https://docs.python.org/3/howto/regex.html
https://docs.python.org/3/library/re.html
https://docs.python.org/3/howto/regex.html#greedy-versus-non-greedy

Metacharacters: . ^ $ * + ? { } [ ] \ | ( )
Metacharacters must be escaped.

.		Any char except a newline character (in alternate mode (re.DOTALL) it matches even a newline)
?		Optional char (0 or 1 char)
*		0 or more instances
+		1 or more instances
^		Matches at the beginning of string/line (re.MULTILINE flag)
$		Matches at the end of a string/line
[]		Character class (a set of characters). For example:
			[a-z]
			[A-Z]
			[0-9]
			[a-zA-Z]
			[^a-zA-Z]
			[a-zA-Z0-9]
			[\s,.] 		match any whitespace character or ',' or '.'.

|		Alternation, “or” operator, e.g. [man|woman]
{n}		Repetition, n times
{n,m}	Repetition, n to m times (incl.)
{n,}	Repetition, n or more times
{,m}	Repetition, zero up to m times.


\d		Matches any decimal digit; this is equivalent to the class [0-9].
\D		Matches any non-digit character; this is equivalent to the class [^0-9].
\s		Matches any whitespace character; this is equivalent to the class [ \t\n\r\f\v].
\S		Matches any non-whitespace character; this is equivalent to the class [^ \t\n\r\f\v].
\w		Matches any alphanumeric character; this is equivalent to the class [a-zA-Z0-9_].
\W		Matches any non-alphanumeric character; this is equivalent to the class [^a-zA-Z0-9_].

\b		Word boundary. Matches only at the beginning or end of a word.


match()		Determine if the RE matches at the beginning of the string.
search()	Scan through a string, looking for any location where this RE matches.
findall()	Find all substrings where the RE matches, and returns them as a list.
finditer()	Find all substrings where the RE matches, and returns them as an iterator.

split()		Split the string into a list, splitting it wherever the RE matches.
sub()		Find all substrings where the RE matches, and replace them with a different string.
subn()		Does the same thing as sub(), but returns the new string and the number of replacements.


re.search(r"man", "mankind")
re.search(r"man", "Mankind", re.IGNORECASE)
re.search(r"\.nl", "tisipi.nl")

re.findall(r"man|woman", "Both man and woman")

pattern = re.compile(r"man|woman")
pattern.findall("Both man and woman")

mo = re.search(r"\[(\d+)\]", "This is a PID [1234] maestro")
mo.group()
mo.group(0)

re.split(r"[.!]", "Split my sentence. This one too! Is it working?")

p = re.compile('(blue|white|red)')
p.sub('colour', 'blue socks and red shoes')
p.sub('colour', 'blue socks and red shoes', count=1)





SSH Access with PEM file
------------------------
download PEM key file
chmod 600 <keyfile>.pem
ssh -i <keyfile>.pem username@<IP Address>

