Pharo
-----
http://pharo.org

A clean, innovative, open-source Smalltalk-inspired environment.

Pharo has a simple dynamically-typed object model:
- Everything is an object (an instance of a class).
- Classes are objects too
- Computation happens only via message sends (and variable assignment).
- There is single inheritance between classes.
- Instance variables are protected.
- Methods are public.
- Blocks are lexical closure a.k.a.anonymous methods.
- Traits are groups of methods that can be reused orthogonally to inheritance.


Learn Pharo
-----------
http://pharo.org
http://pharo.org/documentation
https://pharoweekly.wordpress.com/

Learn Pharo in Pharo itself by using professor Stef:
	ProfStef go.
	ProfStef next.
	ProfStef previous.

Massive Open Online Course  http://mooc.pharo.org
Pharo Books                 http://books.pharo.org
Updated Pharo by Example    https://github.com/SquareBracketAssociates/UpdatedPharoByExample
Screencasts                 https://www.youtube.com/channel/UCp3mNigANqkesFzdm058bvw
Presentations               http://www.slideshare.net/pharoproject/
Cheat-sheet                 https://files.pharo.org/media/flyer-cheat-sheet.pdf
Misc Articles               https://medium.com/concerning-pharo

Notes below are primarily learned from these resources.


Comments
--------
"This is a comment in Pharo Smalltalk"


Assignment
----------
:=


Variable Declaration
--------------------
| foo |			  "Declaration of one variable"
| foo bar |	  "Declaration of tow variables"



Messages, Selectors
-------------------
A method is called by sending a message to an object,the message receiver; the message returns an object. Messages are modeled from natural languages, with a subject, a verb and complements.

There are three types of messages:
- unary,
- binary,
- keyword.


A unary message is one with no arguments:

	Array new.          The message new is sent to the class Array (instance creation).
	2 squared           The message squared is sent to an integer.
	-3 abs.							The message absolute is sent to an integer.
	#(1 2 3) size.			The message size is sent to an array.


A binary message takes only one argument and is named by one or more symbol characters:

	3 + 4.                The + message is sent to the object 3 with 4 as the argument.
	’Hello’, ’ World’.    The string ’Hello’ receives the message , (comma) with ’ World’ as the argument.


A keyword message can take one or more arguments that are inserted in the message name:

	’Smalltalk’ allButFirst: 5.  Sends the message allButFirst: to a string, with the argument 5 (this returns the string ’talk’).
	3 to: 10 by: 2.              Sends to:by: to 3, with arguments 10 and 2 (this returns a collection containing 3, 5, 7 and 9).



Messages Precedence
-------------------
Unary messages are executed first, then binary messages and finally keyword messages:

	Unary > Binary > Keyword


Or more precise:

	Parentheses > Unary > Binary > Keyword, and finally from left to right.


	2 + 3 squared.            Returns 11.
	2 raisedTo: 3 + 2.        Returns 32


Between messages of similar precedence, expressions are executed from left to right:
	-3 abs negated reciprocal.


Use parentheses to change order of evaluation
	(2 + 3) squared.
	(2 raisedTo: 3) + 2.


The rule suffers no exception: operators are just binary messages with no notion of mathematical precedence.
Traditional precedence rules from mathematics do not apply in Pharo.
Remember that all messages always follow a simple left-to-right precedence rule.
	2 * 10 + 2.
	2 + 2 * 10.
	2 + (2 * 10).


Cascading Messages
------------------
Multiple messages can be sent to the same receiver with ;.
; is the cascade operator.

	OrderedCollection new
		add: #abc;
		add: #def;
		add: #ghi.

The value of the whole message cascade is the value of the last message sent.
To return the receiver of the message cascade instead, make sure to send yourself as the last message of the cascade.



Classes
-------
Classes are defined by sending the message subclass: to the class Object.
Class names start with uppercase.

Object subclass: #Counter
 instanceVariableNames: 'count'

Object subclass: #Point
 instanceVariableNames: 'x y'


A class is an instance of another class.
Class X is always the unique instance of the class called "X class"
The class called "X class" is automatically created; it is a metaclass.




Inheritance
-----------
Inheritance allows a class to refine state and behavior.
A class extends the definition of its superclass.
A subclass can:
- add state and behavior;
- use superclass behavior and state;
- specialize and redefine superclass behavior.
A class has 1 and only 1 superclass.
A class eventually inherits from Object.
Object is the root of most classes.
ProtoObject is Object’s superclass (it is for special purposes).

Inheritance of state is static (i.e., during class creation).
Inheritance of behavior is dynamic (i.e., during execution).

Inheritance of Instance Variables:
- happens during class definition
- computed from the class own instance variables and the ones of its superclasses,

Inheritance of Behavior:
- happens at runtime;
- the method is searched starting from the receiver’s class then going to the superclass.


Inheritance, Lookup, self, super
--------------------------------
Sending a message is a two-step process:
1. Look up the method matching the message.
2. Execute this method on the receiver.


Method lookup:
- Maps a message to a method.
- Method lookup starts in the class of the receiver
  - if the method is defined in the class, it is returned
  - if the method is not found the search continues in the superclass (it goes up in the hierarchy).


self always represents the receiver of the message.
self in Pharo, this in Java.
The method lookup starts in the class of the receiver

super refers to the receiver of the message (just like self) !!!
super changes where the lookup starts.
The method lookup starts in the superclass of the class containing the super expression !!!
NOTE this WRONG definition: super looks for the method in the superclass of the receiver’s class.

When no method is found during lookup in the class hierarchy:
- doesNotUnderstand: is sent to the receiver.
- The initial message is passed as parameter.
- When doesNotUnderstand: arrives at Object instance, an error is raised.
- doesNotUnderstand: is a message and any class can implement the corresponding method;
	used for automatic delegation, proxy, distribution.
- When no class redefines doesNotUnderstand: it is executed in Object:
		- It raises a MessageNotUnderstood exception;
		- When not handled, this exception opens a debugger.


Catching MessageNotUnderstood Error:

	[ self sayHi ]
		on: MessageNotUnderstood
		do: [ Transcript show: 'Something wrong here' ]



Return Values
-------------
Use the caret ^ to return a value from a method.
The caret ^ always terminates the method.
A method returns self by default (a method with no caret ^ returns self).

A block returns the result of its last expression.



Variables
---------
Lowercase are used for local/private/temporary variables.
Uppercase are used for shared or global variables.

Local variables start with lowercase (temporary variables, instance variables, arguments,...).

	CounterTest >> testIncrement
	 |c|
	 c := Counter new.
	 ...


Shared or global variables start with uppercase (class, class variables).

	Object is a class globally accessible:
	 Object subclass: #Point

	Transcript is an object that is globally accessible (a kind of stdout):
	 Transcript cr.
	 Transcript show: 'hello world'.



ClassVariables are shared variables. To share information between all the instances of a class and subclasses use a classVariable:

	Object subclass: #CombinedChar
	 instanceVariableNames: 'codes combined'
	 classVariableNames: 'Compositions Decompositions Diacriticals'
	 package: 'Kernel−BasicObjects'


Special variables cannot be changed: true, false, nil self, super, thisContext
	- true, false are the Booleans
		- true is the unique instance of the class True
		- false is the unique instance of the class False

 	- nil is a global and special variable that refers to the only instance of class UndefinedObject.
	- nil is the unique instance of the class UndefinedObject

	- self refers to the receiver of the message (this in Java).
	- super refers to the receiver but the method lookup starts in the superclass of the class defining the method.

	- thisContext refers to the current execution stack (advanced)


System info
-----------
SmalltalkImage current aboutThisSystem.
SystemVersion current.



Date and Time
-------------
Date today.
Date yesterday.
Date today + 3 weeks.
Date today < Date yesterday.

Time now.
DateAndTime today.



Console Output
--------------
Transcript open.
Transcript show: 'Hello '.
Transcript show: 'Pharo'.
Transcript cr.
Transcript clear


Using the cascade operator:

	Transcript
		   show: 'Hello ';
		   show: 'Pharo';
		   cr.



Separator
---------
. is a separator (not a terminator).



Booleans, Conditions
--------------------
true is the unique instance of class True.
false is the unique instance of class False.

& | not
or: and: 			"lazy evaluation"
xor:
ifTrue:ifFalse:
ifFalse:ifTrue: ...


true
false
false not.
true | false.
true & false.

true or: false.
true and: false.

3 < 10
	ifTrue: [Transcript show: 'Indeed, 3 is less than 10'].

myProtocol
  ifEmpty: [ 'As yet unclassified' ]

self listItems
  ifNotEmpty: [ :aList | aList at: index ]

Notice that when the receiver is not empty we get it as argument (no need to ask it again).



Loops
-----
Loops are high-level collection iterators, implemented as regular methods. Some loops:
  to:do:
  to:by:do:
  timesRepeat:

1 to: 100 do: [:i | Transcript show: i asString; cr].
1 to: 100 by: 3 do: [:i | Transcript show: i asString; cr].
100 to: 0 by: -2 do: [:i | Transcript show: i asString; cr].

3 timesRepeat: [Transcript show: 'Yes yes';cr]


whileTrue:
whileFalse:



Numbers, Fractions, Floats
--------------------------
1 class.
1 class maxVal.

9 squared.
5 between: 4 and: 6
1 max: 3.

1 odd.
2 even.
-3 abs.
3 negated.
3 reciprocal.
5 factorial

Integer primesUpTo: 14
(Integer primesUpTo: 14) sum



1/3.
(1/3) class.          "This is a Fraction"
(1/3) + (4/5).


(1/3) asFloat.        "This is a float"
Float pi.
355 / 113 closeTo: Float pi




Characters
----------
A Character is instantiated using $ operator.
	$A.
	$A class.
	$B charCode.
	Character cr.
	Character space.

Print all 256 characters of the ASCII extended set:
	Character allByteCharacters.



Strings
-------
A String is a collection of characters. Use single quotes to create a String object.

	'ProfStef'.
	'ProfStef' size.
	'abc' asUppercase.
	'abc' asLowercase.
	'Hello World' reverse.

You can access each character using at: message.
Index starts at 1, not at 0.
	'ProfStef' at: 1.

String concatenation uses the comma operator:
	'ProfStef', ' is cool'.


$- split: '1969-07-20'
Character space split: 'A Symbol is a String which is guaranteed to be globally unique'

$/ join: ($- split: '1969-07-20') reverse

Character space join: #('This' 'is' 'crazy')
$_ join: #('This' 'is' 'crazy')



Symbols
-------
A Symbol is a String which is guaranteed to be globally unique.
There is one and only one Symbol #ProfStef. There may be several 'ProfStef' String objects.
(Message == returns true if the two objects are the SAME).

'ProfStef' asSymbol.
#ProfStef asString.
(2 asString) == (2 asString).
(2 asString) asSymbol == (2 asString) asSymbol.
(Smalltalk globals at: #ProfStef ProfStef) next.



Associations / Pairs
--------------------
An Association defines a key/value pair:
	'January' -> 31.
	('January' -> 31) key.
	('January' -> 31) value.


Teapot configure: { #defaultOutput −> #json. #port −> 8181 . #debugMode −> true }.



Collections
===========
First element is at index 1.
Collections can contain any sort of objects (collections are heterogenous).
Common collections:
- Array 							(fixed size, direct access)
- OrderedCollection 	(dynamically growing)
- Set 								(no duplicates)
- Dictionary					(key-based, aka. maps)


Common messages working on all collections:
1. Creation: with: anElt, with:with:, withAll: aCollection
2. Accessing: size, at: anIndex, at: anIndex put: anElt
3. Testing: isEmpty, includes: anElt, contains: aBlock
4. Adding: add: anElement, addAll: aCollection
5. Removing: remove: anElt, remove: anElt ifAbsent: aBlock, removeAll: aCollection
6. Enumerating: do: aBlock, collect: aBlock, select: aBlock, reject: aBlock, detect: aBlock, ...
7. Converting: asBag, asSet, asOrderedCollection, asSortedCollection, asArray


Collections - Arrays
--------------------
Collections and thus Arrays start at index 1 (so not 0).

#(7 7 3 13).
#(7 'test' 3 'yes yes').
#(2 4 4 4 5 5 7 9) stdev.
#(2 4 4 4 5 5 7 9) average.
#(2 4 4 4 5 5 7 9) - 1.

Array new: 3.
> #(nil nil nil)


(Array new: 3)
	at: 1 put: 'I';
	at: 2 put: 'am';
	at: 3 put: 'crazy';
	yourself.


#('I' 'am' 'crazy') at: 3.

| me |
me := #('I' 'am' 'crazy').
me at: 3 put: 'not crazy'.


Array with: 'I' with: 'am' with: 'crazy'.


Literal arrays contain objects that have a textual (literal) representation: numbers, strings, nil, symbols. Literal arrays are created at parse time:
	#(1 2 3).
	#(1 2 3 #(4 5 6)) size.
	#(1 2 4) isEmpty.
	#(1 2 3) first.
	#(1 2 3) last.
	#(1 2 3) at: 3.
	#('hello' 'World') at: 2 put: 'Pharo'; yourself.

Dynamic Arrays are created at execution time:
	{ (2+3) . (6*6) }.
	{ (2+3) . (6*6) . 'hello', ' Stef'}



Collections - OrderedCollection
-------------------------------
- Sequenceable
- Growing size
- add:
- remove:
- addFirst:


OrderedCollection new: 3.

OrderedCollection new: 3 withAll: 'a'
> an OrderedCollection('a' 'a' 'a')

OrderedCollection withAll: #(7 7 3 13)
> an OrderedCollection(7 7 3 13)

OrderedCollection new
  add: 56;
  add: 33;
  yourself.


| ordCol |
ordCol := OrderedCollection new.
ordCol add: 'Two'; add: 'Three'; addFirst: 'One'.



Collections - Set
-----------------
- Mathematical set, so no duplicates.
- Growing size.
- Can contain any object including other Sets.
- add:
- remove:


Set newFrom: #(1 2 3).
Set newFrom: {1. 2. 3}.
Set withAll: #(1 2 3).

Set with: 1 with:2 with 3.


#(1 2 3) asSet.
#(1 2 3) as: Set.

{1. 2. 3} asSet.
{1. 2. 3} as: Set.


Set withAll: #(7 7 3 13).
> a Set( 7 3 13).


#(a b c d e f) asSet intersection: #(f d b) asSet



Collections - Dictionary
------------------------
- Key/values.
- Growing size.
- Accessing: at:, at:ifAbsent:, keys, values.
- Changing/adding: at:put:, at:ifAbsentPut:
- Iterating: do:, keysDo:, valuesDo:, keysAndValuesDo:


| days |
days := Dictionary new.
days
	at: #January put: 31;
	at: #February put: 28;
	at: #March put: 31.


| days |
days := { #January -> 31. #February -> 28. #March -> 31} asDictionary.
days at: #February.
days at: #FakeMonth.
days at: #FakeMonth ifAbsent: [0]   "Hmmm, I still get a KeyNotFound in Pharo 8 MOOC..."


days keys.
days values.

days keysDo: [ :key | Transcript show: key; cr ].
days valuesDo: [ :value | Transcript show: value; cr ]
days keysAndValuesDo: [ :k :v | Transcript show: k asString, ' is having ', v asString  , ' days' ; cr].



Collections - Conversion
------------------------
Collections can be converted simply to other collections:
- asOrderedCollection
- asSet
- asArray



Blocks (closures)
-----------------
Blocks are objects containing code that is executed on demand (anonymous functions).
Blocks are anonymous methods that can be stored into variables and executed on demand.
Blocks are the basis for control structures like conditionals and loops.
Blocks are delimited by square brackets: [].
Blocks are executed when they are evaluated.
Block execution returns the value of the last expression.
Blocks may contain temporary variables.
Use blocks with 2 or 3 arguments maximum.
A block encapsulates only one computation.

[:x | x * x ] value:12.
[:x :y | x + y] value:3 value:5.
[GTPlayground open] value.
[ProfStef next] value.

|b|
b := [:x | x+2].
b value: 12.


2 = 2
	ifTrue: [Error signal: 'Help'].

#('Hello World' 'I like Pharo') do: [:e | Transcript show: e].



( ) vs. [ ]:
- ( ) just changes the priority of an execution but the program is executed
- [ ] blocks program execution: the program is NOT executed
- ( ) is about changing the order of a computation
- [ ] is freezing the computation and controlling it


Use [ expressions ] when:
- expressions may not be executed at all (if, and, ...)
- expressions may be executed multiple times (while, ...)



Iterators
---------
With iterators we tell the collection (Array, Set, OrderedCollection) to iterate on itself.
As a client we do not have to know the internal logic of the collection.

do:              Iterate and apply the block on each element ('side effect')
collect:         Iterate and collect results of the block evalutation.
select:          Select matching elements (filter).
reject:          Reject matching elements (filter; selects non-matching elements).
detect:          Get first element matching.
detect:ifNone:   Get first element matching or a default value.
includes:        Test inclusion.


NOTE: When a block is just one UNARY message, no block is needed. These are equivalent:

	#(16 11 68 19) select: [ :i | i odd ]
	#(16 11 68 19) select: #odd


#(11 38 3 -2 10) collect: [:each | each abs].
#(11 38 3 -2 10) collect: [:each | each odd].

#(11 38 3 -2 10) select: [:each | each odd].
#(11 38 3 -2 10) select: [:each | each > 10].

#(11 38 3 -2 10) reject: [:each | each > 10].


(1 to: 10) asOrderedCollection collect: [ :i | i squared ].
(1 to: 10) asOrderedCollection collect: #squared.


(1914 to: 1945) select: [:each | Year isLeapYear: each].
(1914 to: 1945) count: [:each | Year isLeapYear: each].


#(11 38 3 -2 10)
	do: [:each | Transcript show: each; cr].

#(11 38 3 -2 10)
     do: [:each | Transcript show: each ]
     separatedBy: [Transcript show: '.'].


#(a b c d e f) includesAll: #(f d b)



To find the first element that matches, use detect:

	#(16 11 68 19) detect: [ :i | i odd ]



Instances
---------
Objects are instances of their class. Usually, we send the message #new to a class for creating an instance of this class.

	SimpleButtonMorph new
		label: 'A nice button';
		openCenteredInWorld.


The message #allInstances sent to a class answers an Array with all instances of this class.

	SimpleButtonMorph allInstances size.


	SimpleButtonMorph allInstances last
		label: 'ProfStef is cooooool !';
		color: Color red.

Delete it and ask the system to clean the memory:

	SimpleButtonMorph allInstances last delete.
	Smalltalk garbageCollect.
	SimpleButtonMorph allInstances size.


Click on the button to go to next lesson:

	SimpleButtonMorph new
		label: 'Go to next lesson';
		target: [ProfStef next.
				   SimpleButtonMorph allInstances last delete];
		actionSelector: #value;
		openCenteredInWorld.


Streams
-------
Streams iterate over a sequence of elements (e.g. collection, file, network).
A stream can read from and write to collections, files and network.
A stream maintains a current position.
The current position separates past from future.
Streams are implemented for example by a.o. an Array and a position.
A stream can help create collections.

When sending readStream or writeStream to an object, always make sure to close the stream. Even better, use auto-closing messages such as readStreamDo: and writeStreamDo:.


Creating:
- anObject readStream
- anObject writeStream
- Collection streamContents: [:stream | ... ]
- ReadStream on: aCollection
- WriteStream on: aCollection

Reading elements:
 - next
 - upTo: anObject
 - upToEnd

Writing elements:
- nextPut: anElement
- nextPutAll: aCollection


Create and read stream:

	| stream |
	stream := #($a $b $c $d $e $f) readStream.
	stream next.
	 > $a
	stream upTo: $d.
	 > #($b $c)
	stream position.
	 >4
	stream upToEnd
	 > #($e $f)


Position in stream:

	stream position.
	"reset postion to 0"
	stream reset.


Create and write stream:

	stream := (Array new: 6) writeStream.
	stream nextPut: 1.
	stream contents.
	 > #(1)
	stream nextPutAll: #(4 8 2 6 7).
	stream contents.
	 > #(1 4 8 2 6 7)


It is not mandatory to reserve elements an array:

	stream := Array new writeStream.
	stream nextPut: 1.
	stream nextPutAll: #(2 3 4 5 6).


Writing to a File:

	stream := 'hello.txt' asFileReference writeStream.
	stream nextPutAll: 'Hello Pharo!'.
	stream close.


Reading from a File:

	stream := 'hello.txt' asFileReference readStream.
	stream next.
	 > $H
	stream next.
	 > $e
	stream upToEnd.
	 > 'llo Pharo!'
	stream close.


Create a collection by writing to a stream:

	stream := OrderedCollection new writeStream.
	stream nextPut: 1.
	stream contents      "Returns a collection with number 1 inside."


Create a collection by writing to a stream (alternative):

	OrderedCollection
		streamContents: [:stream | stream nextPut: 1]



Reflection
----------
(Number>>#abs) definition.
(Number>>#abs) comment.
Number selectors.
Number selectors select: #isUnary.
Number respondsTo: #isNumber.

(True>>#ifTrue:) definition.
(True>>#ifTrue:) comment.
True selectors.

Date today inspect.
Date browse.


yourself
--------
|s|
s := Set new.
s add: 2.
s

Equivalent to:

Set new
  add:2;
  yourself


	Note: The method add: returns its argument, not the receiver.
	  Set new add: 2
	  >2
	We get 2 and not the set!


The cascade returns the value of the last message sent to the object.
When creating a new object, after sending several messages to configure it with a cascade,
yourself is the simplest way to get the new object as a result of the whole expression.



File Manipulation
-----------------

FileSystem is a low-level protocol for interacting with filesystems. FileSystem instances know two methods that return a Reference object: workingDirectory and root.

FileSystem disk workingDirectory.                  "FileReference on working directory"
FileSystem disk root.                              "FileReference on root"

FileSystem disk workingDirectory files.
FileSystem disk workingDirectory directories.


FileReference provides methods for navigating the filesystem, performing filesystem operations and opening and closing files. It is the primary mechanism for working with files and directories.


FileLocator refers to a file or directory in relation to a well-known location on the filesystem, called an origin. When asked to perform concrete operation, I look up the current location of my origin, and resolve my path against it.

FileLocator documents.
FileLocator documents pathString.

FileLocator workingDirectory
FileLocator workingDirectory filesMatching: '*.pdf'

FileLocator desktop.
FileLocator desktop basename.
FileLocator home basename.

FileLocator image.
FileLocator imageDirectory

FileLocator vmDirectory parent pathString
FileLocator vmBinary asAbsolute pathString
FileLocator vmBinary pathString



Thread
------
# java: new Thread (() -> this.doSomething()).start();

[self doSomething] fork



ZnClient, Zinc HTTP Client
--------------------------
ZnClient, a full featured HTTP client.
An object to build, execute and process HTTP client requests.
Part of Zinc HTTP Components.

Some examples:

	ZnClient new
		get: 'http://zn.stfx.eu/zn/numbers.txt'.

	ZnClient new
		url: 'http://pharo.org';
		get.

	ZnClient new
		get: 'http://pharo.org'.


An explicit constructed HTTP request:

	ZnClient new
		systemPolicy;
		accept: ZnMimeType textPlain;
		http;
		host: 'zn.stfx.eu';
		path: 'zn/numbers.txt';
		contentReader: [ :entity | entity contents lines collect: [ :each | each asNumber ] ];
		ifFail: [ :exception | self inform: 'I am sorry: ', exception printString ];
		get.



ZnEasy, HTTP Client
-------------------
A simplified HTTP client for occasional use.
It uses ZnClient.
For most requests it returns a response object.

	ZnEasy get: 'http://zn.stfx.eu/zn/small.html'.


For a couple of messages, it returns an image Form:

	ZnEasy getGif: 'http://zn.stfx.eu/zn/Hot-Air-Balloon.gif'

	ZnEasy getPng: 'http://pharo.org/files/pharo.png'.

	ZnEasy getJpeg: 'http://stfx.eu/sun-fire-x2100.jpg'.



| url |.
url := 'http://pharo.org/web/files/pharo.png'.
(ZnEasy getPng: url) asMorph openInWorld.
(ZnEasy getPng: url) asMorph openInWindow


| anEmail md5Email url |.
anEmail := 'Stephane.Ducasse@inria.fr' trimBoth asLowercase.
md5Email := (MD5 new hashMessage: anEmail) hex.
url := 'http://www.gravatar.com/avatar/' , md5Email , '.jpg'.
(ZnEasy getJpeg: url) asMorph openInWorld.




Teapot, Web Framework
---------------------
Teapot is micro web framework for Pharo Smalltalk on top of the Zinc HTTP components.

Teapot source and documentation:	https://github.com/zeroflag/Teapot


Example of a simple HTTP Teapot server running on (default) port 1701 with one route (for welcome):

		Teapot on
		    GET: '/welcome' -> 'Hello World!';
		    start.

		Do it and view it at: http://localhost:1701/welcome


Please note: Normally, the first letter of a method name (and corresponding message) should be lower case, that's the recommended naming scheme.
In this case, the author of Teapot decided to ignore this scheme to better reflect the HTTP protocol where verbs (such as GET, POST, PUT and DELETE) are typically written uppercased.



"The Teapot HTTP server"
books := Dictionary new.
teapot := Teapot configure: { #defaultOutput −> #json. #port −> 8181 }.
teapot
 GET: '/' −> '<h1>A simple book server</h1>';output: #html;
 GET: '/books' −> books;
 GET: '/books/<id:IsInteger>'
 	−> [ :request | books at: (request at: #id) asString];
 POST: '/books/<id>'
 	−> [ :request | | book |
 			book := { 'author' −> (request at: #author). 'title' −> (request at: #title) } asDictionary.
 			books at: (request at: #id) put: book ];
 start.


"Add a book via HTTP client"
ZnClient
 new url: 'http://localhost:8181/books/1';
 formAt: 'author' put: 'van Caekenberghe et al';
 formAt: 'title' put: 'Enterprise Pharo';
 post.


"Get a book via HTTP client"
ZnClient new
 url: 'http://localhost:8181/books/1';
 get.



Tealight
--------
https://github.com/astares/Tealight

Tealight is a project defining a few extensions to the Teapot framework to make the (tea) time you spend with the Pharo Teapot system even easier.



ZnUrl
-----
ZnUrl, an implementation of an interpreted URL/URI.
URLs are used to describe/identify resources,
Part of Zinc HTTP Components.


Creating a ZnUrl:

	'http://www.pharo.org' asUrl.
	'http://www.pharo.org' asZnUrl.

	ZnUrl fromString: 'http://www.pharo.org'.
	ZnUrl fromString: 'http://www.google.com/search?q=Smalltalk'.
	ZnUrl fromString: 'www.example.com' defaultScheme: #http

  ZnUrl new
    scheme: #https;
    host: 'encrypted.google.com';
    addPathSegment: 'search';
    queryAt: 'q' put: 'Smalltalk';
    yourself.


Manipulating a ZnUrl:

  'http://www.google.com/?one=1&two=2' asZnUrl
    queryAt: 'three' put: '3';
    queryRemoveKey: 'one';
    yourself.


Convenience method #retrieveContents to download the resource a ZnUrl points to:

	'http://www.pharo.org' asUrl retrieveContents.
	'http://www.pharo.org' asZnUrl retrieveContents.

  'http://zn.stfx.eu/zn/numbers.txt' asZnUrl retrieveContents.



ZnServer, HTTP Server
---------------------

(ZnServer startDefaultOn: 8080)
  onRequestRespond: [ :request |
    ZnResponse ok: (ZnEntity with: DateAndTime now printString) ]

Go to http://localhost:8080 to see the current date and time



Unit Testing
------------
Pharo has a powerful framework that supports the creation and deployment of tests.
A test must be implemented:
- in a method whose name has a test prefix
- in a class that subclasses TestCase.


Example:

	TestCase subclass: #TBPostTest
		instanceVariableNames: ''
		classVariableNames: ''
		package: 'TinyBlog-Tests'


	TBPostTest >> testNewPostVisible
		| post |
		post := TBPost title: 'First Post' text: 'My first tiny post inside Pharo' category: 'Pharo'.
		post beVisible.

		self assert: post title equals: 'First Post'.
		self assert: post text equals: 'My first tiny post inside Pharo'.
		self assert: post date equals: Date today.
		self assert: post category equals: 'Pharo'.
		self assert: post isVisible.



+++++

12 2r1100 16rC twelve(decimal,binary,hexadecimal)
3.14 1.2e3 floating-pointnumbers
. expressionseparator(period)
; messagecascade(semicolon)

^ returnaresultfromamethod(caret)
[ :p | expr] codeblockwithaparameter
#(abc 123) literalarraywiththesymbol#abc and
thenumber123
{foo . 3 + 2} dynamicarraybuiltfrom2expressions
++++


Object subclass: #TBPost
	instanceVariableNames: 'title text date category visible'
	classVariableNames: ''
	package: 'TinyBlog'

Object subclass: #TBPost
	slots: { #title. #text. #date. #category. #visible }
	classVariables: {  }
	package: 'TinyBlog'


initialize
	super initialize.
	self date: Date today.
	self category: (self class unclassifiedTag).
	self notVisible.



title: aTitle text: aText
	^ self new
			title: aTitle;
			text: aText;
			yourself


TBPost new.
TBPost title: 'First post' text: 'My first post' category: 'Pharo'


Abstract Base Class:
method
	self subclassResponsibility

---

MenubarMorph reset.


A Point:
	10 @ 100.


Color red
Color r:1 g:0 b:0.

'Hello World' asMorph openInWindow .


Open a playground:
	GTPlayground open.
	Workspace open.


-----
https://medium.com/concerning-pharo/elegant-pharo-code-bb590f0856d0
Here is an implementation of a basic grep on a single file.

'^.*.jpg' asRegex in: [ :regex |
  '/tmp/foo.txt' asFileReference contents lines
    select: [ :line | regex matches: line ] ]

The pattern String is converted to an object that knows how to match lines. The file is opened by taking its contents and converting it to lines which are selected when they match.


Which are the leap years between 1895 and 1915 ? 1896, 1904, 1908 and 1912.

(1914 to: 1945) count: [ :each | Year isLeapYear: each ].
(1895 to: 1915) select: [ :each | Year isLeapYear: each ].

 Find out which server is serving a web page

As a live environment, Pharo allows you to look at all objects involved in a computation. This includes the HTTP request and response objects. We can access the response object to find out which server is serving a particular web page — by consulting the identification String in the ‘Server’ header. Pharo.org is served by ‘Zinc HTTP Components 1.0'.

(ZnClient new beOneShot; get: 'http://www.pharo.org'; response)
   headers at: #Server

In this case we are not interested in the result of the GET request itself, but in the response object. We also tell the HTTP client that it will only be used once — so that it can close the connections cleanly.

-----

| sum |
sum := 0.
#(21 23 53 66 87) do: [:item | sum := sum + item].
sum.

| sum |.
sum := 0.
numbers := #(21 23 53 66 87).
i := 1.
[i <= numbers size]
	whileTrue: [ 	sum := sum + (numbers at: i). 		i := i + 1 ].
sum.


#(21 23 53 66 87) inject: 0 into: [ :sum :each |  sum + each ].

---

| array |
array := #(2 4 4 4 5 5 7 9).
((array - array average) squared sum / (array size - 1)) sqrt

[ :input | ((input - input average) squared sum / (input size - 1))
sqrt ] value: #(2 4 4 4 5 5 7 9)

#(2 4 4 4 5 5 7 9) in: [ :input |
((input - input average) squared sum / (input size - 1)) sqrt ]

#(2 4 4 4 5 5 7 9) stdev

-----


MOOC
----
Done:
1, 2

Todo:
2.14.3.[Mini-projet] Chap.3 TinyBlog: Extending and Testing the Model
3.14.2 challenge 2